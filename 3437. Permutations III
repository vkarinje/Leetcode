class Solution {
    // Main method to generate all valid permutations of numbers from 1 to n
    public int[][] permute(int n) {
        // Step 1: Initialize the nums array with numbers from 1 to n
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1; // nums = [1, 2, ..., n]
        }

        // Step 2: Initialize auxiliary data structures
        int[] candidate = new int[n]; // Holds the current permutation being built
        boolean[] used = new boolean[n]; // Tracks which numbers are used
        List<List<Integer>> permutations = new ArrayList<>(); // Stores all valid permutations

        // Step 3: Start the recursive backtracking process
        permute(nums, 0, used, candidate, permutations);

        // Step 4: Convert the list of permutations to a 2D array
        int[][] result = new int[permutations.size()][n];
        for (int i = 0; i < result.length; i++) {//calculates row
            for (int j = 0; j < result[0].length; j++) {//calculates columns
                result[i][j] = permutations.get(i).get(j);
            }
        }

        // Step 5: Return the 2D array of permutations
        return result;
    }

    // Recursive helper method for generating permutations
    private void permute(int[] nums, int pos, boolean[] used, int[] candidate, List<List<Integer>> permutations) {
        // Base Case: If the current position equals the length of nums,
        // it means we have formed a complete permutation
        if (pos == nums.length) {
            // Convert the candidate array to a list and add to permutations
            List<Integer> res = new ArrayList<>();
            for (int i = 0; i < candidate.length; i++) {
                res.add(candidate[i]);
            }
            permutations.add(res); // Store the current permutation
            return; // Backtrack to explore other permutations
        }

        // Step 6: Loop through all numbers to build the permutation
        for (int i = 0; i < nums.length; i++) {
            // Check if the current number is already used
            if (!used[i]) {
                // Check the odd-even alternation condition
                // Either it's the first position OR
                // The current number must have a different parity than the previous one
                if (pos == 0 || candidate[pos - 1] % 2 != nums[i] % 2) {
                    // Place the current number at the current position
                    candidate[pos] = nums[i];
                    used[i] = true; // Mark as used

                    // Recursively fill the next position
                    permute(nums, pos + 1, used, candidate, permutations);

                    // Backtrack: Unmark the number to try other possibilities
                    used[i] = false;
                }
            }
        }
    }
}
This problem generates all permutations of numbers from 1 to n, ensuring no two consecutive numbers are both odd or both even.

Approach:
We use backtracking to build permutations step by step, storing numbers in a candidate array. A used boolean array tracks which numbers are already in the permutation. We check at each step to ensure no two consecutive
numbers have the same parity (odd/even).

Time Complexity: O(n! * n)

There are n! possible permutations.
Each permutation takes O(n) to copy to the result list.
Space Complexity: O(n! * n)

Storing all permutations requires n! arrays of length n.
Recursive call stack uses O(n) space.
This approach is efficient because it prunes invalid branches early by checking the odd-even condition, reducing unnecessary calculations.
